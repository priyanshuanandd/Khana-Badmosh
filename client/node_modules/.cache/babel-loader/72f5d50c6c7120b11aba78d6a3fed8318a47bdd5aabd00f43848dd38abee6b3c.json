{"ast":null,"code":"/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module exports.\r\n * @public\r\n */\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\r\n * Module variables.\r\n * @private\r\n */\n\nvar __toString = Object.prototype.toString;\n\n/**\r\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\r\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\r\n * which has been replaced by the token definition in RFC 7230 appendix B.\r\n *\r\n * cookie-name       = token\r\n * token             = 1*tchar\r\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\r\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\r\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\r\n */\n\nvar cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n\n/**\r\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\r\n *\r\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n *                     ; US-ASCII characters excluding CTLs,\r\n *                     ; whitespace DQUOTE, comma, semicolon,\r\n *                     ; and backslash\r\n */\n\nvar cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n\n/**\r\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\r\n *\r\n * domain-value      = <subdomain>\r\n *                     ; defined in [RFC1034], Section 3.5, as\r\n *                     ; enhanced by [RFC1123], Section 2.1\r\n * <subdomain>       = <label> | <subdomain> \".\" <label>\r\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\r\n *                     Labels must be 63 characters or less.\r\n *                     'let-dig' not 'letter' in the first char, per RFC1123\r\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\r\n * <let-dig-hyp>     = <let-dig> | \"-\"\r\n * <let-dig>         = <letter> | <digit>\r\n * <letter>          = any one of the 52 alphabetic characters A through Z in\r\n *                     upper case and a through z in lower case\r\n * <digit>           = any one of the ten digits 0 through 9\r\n *\r\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\r\n *\r\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\r\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\r\n * cause the user agent to ignore the attribute.)\r\n */\n\nvar domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n/**\r\n * RegExp to match path-value in RFC 6265 sec 4.1.1\r\n *\r\n * path-value        = <any CHAR except CTLs or \";\">\r\n * CHAR              = %x01-7F\r\n *                     ; defined in RFC 5234 appendix B.1\r\n */\n\nvar pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\n/**\r\n * Parse a cookie header.\r\n *\r\n * Parse the given cookie header string into an object\r\n * The object has the various cookies as keys(names) => values\r\n *\r\n * @param {string} str\r\n * @param {object} [opt]\r\n * @return {object}\r\n * @public\r\n */\n\nfunction parse(str, opt) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n  var obj = {};\n  var len = str.length;\n  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n  if (len < 2) return obj;\n  var dec = opt && opt.decode || decode;\n  var index = 0;\n  var eqIdx = 0;\n  var endIdx = 0;\n  do {\n    eqIdx = str.indexOf('=', index);\n    if (eqIdx === -1) break; // No more cookie pairs.\n\n    endIdx = str.indexOf(';', index);\n    if (endIdx === -1) {\n      endIdx = len;\n    } else if (eqIdx > endIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1;\n      continue;\n    }\n    var keyStartIdx = startIndex(str, index, eqIdx);\n    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n    var key = str.slice(keyStartIdx, keyEndIdx);\n\n    // only assign once\n    if (!obj.hasOwnProperty(key)) {\n      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n      var valEndIdx = endIndex(str, endIdx, valStartIdx);\n      if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\n        valStartIdx++;\n        valEndIdx--;\n      }\n      var val = str.slice(valStartIdx, valEndIdx);\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  } while (index < len);\n  return obj;\n}\nfunction startIndex(str, index, max) {\n  do {\n    var code = str.charCodeAt(index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n  } while (++index < max);\n  return max;\n}\nfunction endIndex(str, index, min) {\n  while (index > min) {\n    var code = str.charCodeAt(--index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n  }\n  return min;\n}\n\n/**\r\n * Serialize data into a cookie header.\r\n *\r\n * Serialize a name value pair into a cookie string suitable for\r\n * http headers. An optional options object specifies cookie parameters.\r\n *\r\n * serialize('foo', 'bar', { httpOnly: true })\r\n *   => \"foo=bar; httpOnly\"\r\n *\r\n * @param {string} name\r\n * @param {string} val\r\n * @param {object} [opt]\r\n * @return {string}\r\n * @public\r\n */\n\nfunction serialize(name, val, opt) {\n  var enc = opt && opt.encode || encodeURIComponent;\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n  if (!cookieNameRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n  var value = enc(val);\n  if (!cookieValueRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n  var str = name + '=' + value;\n  if (!opt) return str;\n  if (null != opt.maxAge) {\n    var maxAge = Math.floor(opt.maxAge);\n    if (!isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid');\n    }\n    str += '; Max-Age=' + maxAge;\n  }\n  if (opt.domain) {\n    if (!domainValueRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += '; Domain=' + opt.domain;\n  }\n  if (opt.path) {\n    if (!pathValueRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += '; Path=' + opt.path;\n  }\n  if (opt.expires) {\n    var expires = opt.expires;\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n    str += '; Expires=' + expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n  if (opt.secure) {\n    str += '; Secure';\n  }\n  if (opt.partitioned) {\n    str += '; Partitioned';\n  }\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low';\n        break;\n      case 'medium':\n        str += '; Priority=Medium';\n        break;\n      case 'high':\n        str += '; Priority=High';\n        break;\n      default:\n        throw new TypeError('option priority is invalid');\n    }\n  }\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  return str;\n}\n\n/**\r\n * URL-decode string value. Optimized to skip native call when no %.\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */\n\nfunction decode(str) {\n  return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;\n}\n\n/**\r\n * Determine if value is a Date.\r\n *\r\n * @param {*} val\r\n * @private\r\n */\n\nfunction isDate(val) {\n  return __toString.call(val) === '[object Date]';\n}\n\n/**\r\n * Try decoding a string using a decoding function.\r\n *\r\n * @param {string} str\r\n * @param {function} decode\r\n * @private\r\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}","map":{"version":3,"names":["exports","parse","serialize","__toString","Object","prototype","toString","cookieNameRegExp","cookieValueRegExp","domainValueRegExp","pathValueRegExp","str","opt","TypeError","obj","len","length","dec","decode","index","eqIdx","endIdx","indexOf","lastIndexOf","keyStartIdx","startIndex","keyEndIdx","endIndex","key","slice","hasOwnProperty","valStartIdx","valEndIdx","charCodeAt","val","tryDecode","max","code","min","name","enc","encode","encodeURIComponent","test","value","maxAge","Math","floor","isFinite","domain","path","expires","isDate","isNaN","valueOf","toUTCString","httpOnly","secure","partitioned","priority","toLowerCase","sameSite","decodeURIComponent","call","e"],"sources":["C:/Users/mepri/OneDrive/Desktop/Codes/PriDevelops/KhanaBadmosh/client/node_modules/cookie/index.js"],"sourcesContent":["/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nexports.parse = parse;\r\nexports.serialize = serialize;\r\n\r\n/**\r\n * Module variables.\r\n * @private\r\n */\r\n\r\nvar __toString = Object.prototype.toString\r\n\r\n/**\r\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\r\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\r\n * which has been replaced by the token definition in RFC 7230 appendix B.\r\n *\r\n * cookie-name       = token\r\n * token             = 1*tchar\r\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\r\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\r\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\r\n */\r\n\r\nvar cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\r\n\r\n/**\r\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\r\n *\r\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n *                     ; US-ASCII characters excluding CTLs,\r\n *                     ; whitespace DQUOTE, comma, semicolon,\r\n *                     ; and backslash\r\n */\r\n\r\nvar cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\r\n\r\n/**\r\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\r\n *\r\n * domain-value      = <subdomain>\r\n *                     ; defined in [RFC1034], Section 3.5, as\r\n *                     ; enhanced by [RFC1123], Section 2.1\r\n * <subdomain>       = <label> | <subdomain> \".\" <label>\r\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\r\n *                     Labels must be 63 characters or less.\r\n *                     'let-dig' not 'letter' in the first char, per RFC1123\r\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\r\n * <let-dig-hyp>     = <let-dig> | \"-\"\r\n * <let-dig>         = <letter> | <digit>\r\n * <letter>          = any one of the 52 alphabetic characters A through Z in\r\n *                     upper case and a through z in lower case\r\n * <digit>           = any one of the ten digits 0 through 9\r\n *\r\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\r\n *\r\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\r\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\r\n * cause the user agent to ignore the attribute.)\r\n */\r\n\r\nvar domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\r\n\r\n/**\r\n * RegExp to match path-value in RFC 6265 sec 4.1.1\r\n *\r\n * path-value        = <any CHAR except CTLs or \";\">\r\n * CHAR              = %x01-7F\r\n *                     ; defined in RFC 5234 appendix B.1\r\n */\r\n\r\nvar pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\r\n\r\n/**\r\n * Parse a cookie header.\r\n *\r\n * Parse the given cookie header string into an object\r\n * The object has the various cookies as keys(names) => values\r\n *\r\n * @param {string} str\r\n * @param {object} [opt]\r\n * @return {object}\r\n * @public\r\n */\r\n\r\nfunction parse(str, opt) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('argument str must be a string');\r\n  }\r\n\r\n  var obj = {};\r\n  var len = str.length;\r\n  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\r\n  if (len < 2) return obj;\r\n\r\n  var dec = (opt && opt.decode) || decode;\r\n  var index = 0;\r\n  var eqIdx = 0;\r\n  var endIdx = 0;\r\n\r\n  do {\r\n    eqIdx = str.indexOf('=', index);\r\n    if (eqIdx === -1) break; // No more cookie pairs.\r\n\r\n    endIdx = str.indexOf(';', index);\r\n\r\n    if (endIdx === -1) {\r\n      endIdx = len;\r\n    } else if (eqIdx > endIdx) {\r\n      // backtrack on prior semicolon\r\n      index = str.lastIndexOf(';', eqIdx - 1) + 1;\r\n      continue;\r\n    }\r\n\r\n    var keyStartIdx = startIndex(str, index, eqIdx);\r\n    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\r\n    var key = str.slice(keyStartIdx, keyEndIdx);\r\n\r\n    // only assign once\r\n    if (!obj.hasOwnProperty(key)) {\r\n      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\r\n      var valEndIdx = endIndex(str, endIdx, valStartIdx);\r\n\r\n      if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\r\n        valStartIdx++;\r\n        valEndIdx--;\r\n      }\r\n\r\n      var val = str.slice(valStartIdx, valEndIdx);\r\n      obj[key] = tryDecode(val, dec);\r\n    }\r\n\r\n    index = endIdx + 1\r\n  } while (index < len);\r\n\r\n  return obj;\r\n}\r\n\r\nfunction startIndex(str, index, max) {\r\n  do {\r\n    var code = str.charCodeAt(index);\r\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\r\n  } while (++index < max);\r\n  return max;\r\n}\r\n\r\nfunction endIndex(str, index, min) {\r\n  while (index > min) {\r\n    var code = str.charCodeAt(--index);\r\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\r\n  }\r\n  return min;\r\n}\r\n\r\n/**\r\n * Serialize data into a cookie header.\r\n *\r\n * Serialize a name value pair into a cookie string suitable for\r\n * http headers. An optional options object specifies cookie parameters.\r\n *\r\n * serialize('foo', 'bar', { httpOnly: true })\r\n *   => \"foo=bar; httpOnly\"\r\n *\r\n * @param {string} name\r\n * @param {string} val\r\n * @param {object} [opt]\r\n * @return {string}\r\n * @public\r\n */\r\n\r\nfunction serialize(name, val, opt) {\r\n  var enc = (opt && opt.encode) || encodeURIComponent;\r\n\r\n  if (typeof enc !== 'function') {\r\n    throw new TypeError('option encode is invalid');\r\n  }\r\n\r\n  if (!cookieNameRegExp.test(name)) {\r\n    throw new TypeError('argument name is invalid');\r\n  }\r\n\r\n  var value = enc(val);\r\n\r\n  if (!cookieValueRegExp.test(value)) {\r\n    throw new TypeError('argument val is invalid');\r\n  }\r\n\r\n  var str = name + '=' + value;\r\n  if (!opt) return str;\r\n\r\n  if (null != opt.maxAge) {\r\n    var maxAge = Math.floor(opt.maxAge);\r\n\r\n    if (!isFinite(maxAge)) {\r\n      throw new TypeError('option maxAge is invalid')\r\n    }\r\n\r\n    str += '; Max-Age=' + maxAge;\r\n  }\r\n\r\n  if (opt.domain) {\r\n    if (!domainValueRegExp.test(opt.domain)) {\r\n      throw new TypeError('option domain is invalid');\r\n    }\r\n\r\n    str += '; Domain=' + opt.domain;\r\n  }\r\n\r\n  if (opt.path) {\r\n    if (!pathValueRegExp.test(opt.path)) {\r\n      throw new TypeError('option path is invalid');\r\n    }\r\n\r\n    str += '; Path=' + opt.path;\r\n  }\r\n\r\n  if (opt.expires) {\r\n    var expires = opt.expires\r\n\r\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\r\n      throw new TypeError('option expires is invalid');\r\n    }\r\n\r\n    str += '; Expires=' + expires.toUTCString()\r\n  }\r\n\r\n  if (opt.httpOnly) {\r\n    str += '; HttpOnly';\r\n  }\r\n\r\n  if (opt.secure) {\r\n    str += '; Secure';\r\n  }\r\n\r\n  if (opt.partitioned) {\r\n    str += '; Partitioned'\r\n  }\r\n\r\n  if (opt.priority) {\r\n    var priority = typeof opt.priority === 'string'\r\n      ? opt.priority.toLowerCase() : opt.priority;\r\n\r\n    switch (priority) {\r\n      case 'low':\r\n        str += '; Priority=Low'\r\n        break\r\n      case 'medium':\r\n        str += '; Priority=Medium'\r\n        break\r\n      case 'high':\r\n        str += '; Priority=High'\r\n        break\r\n      default:\r\n        throw new TypeError('option priority is invalid')\r\n    }\r\n  }\r\n\r\n  if (opt.sameSite) {\r\n    var sameSite = typeof opt.sameSite === 'string'\r\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\r\n\r\n    switch (sameSite) {\r\n      case true:\r\n        str += '; SameSite=Strict';\r\n        break;\r\n      case 'lax':\r\n        str += '; SameSite=Lax';\r\n        break;\r\n      case 'strict':\r\n        str += '; SameSite=Strict';\r\n        break;\r\n      case 'none':\r\n        str += '; SameSite=None';\r\n        break;\r\n      default:\r\n        throw new TypeError('option sameSite is invalid');\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n/**\r\n * URL-decode string value. Optimized to skip native call when no %.\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\n\r\nfunction decode (str) {\r\n  return str.indexOf('%') !== -1\r\n    ? decodeURIComponent(str)\r\n    : str\r\n}\r\n\r\n/**\r\n * Determine if value is a Date.\r\n *\r\n * @param {*} val\r\n * @private\r\n */\r\n\r\nfunction isDate (val) {\r\n  return __toString.call(val) === '[object Date]';\r\n}\r\n\r\n/**\r\n * Try decoding a string using a decoding function.\r\n *\r\n * @param {string} str\r\n * @param {function} decode\r\n * @private\r\n */\r\n\r\nfunction tryDecode(str, decode) {\r\n  try {\r\n    return decode(str);\r\n  } catch (e) {\r\n    return str;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}