{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:urlencoded');\nvar deprecate = require('depd')('body-parser');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\r\n * Module exports.\r\n */\n\nmodule.exports = urlencoded;\n\n/**\r\n * Cache of parser modules.\r\n */\n\nvar parsers = Object.create(null);\n\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\n\nfunction urlencoded(options) {\n  var opts = options || {};\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option');\n  }\n  var extended = opts.extended !== false;\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/x-www-form-urlencoded';\n  var verify = opts.verify || false;\n  var depth = typeof opts.depth !== 'number' ? Number(opts.depth || 32) : opts.depth;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended ? extendedparser(opts) : simpleparser(opts);\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(body) {\n    return body.length ? queryparse(body) : {};\n  }\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8';\n    if (charset !== 'utf-8') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify,\n      depth: depth\n    });\n  };\n}\n\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\n\nfunction extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var depth = typeof options.depth !== 'number' ? Number(options.depth || 32) : options.depth;\n  var parse = parser('qs');\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isNaN(depth) || depth < 0) {\n    throw new TypeError('option depth must be a zero or a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    var arrayLimit = Math.max(100, paramCount);\n    debug('parse extended urlencoding');\n    try {\n      return parse(body, {\n        allowPrototypes: true,\n        arrayLimit: arrayLimit,\n        depth: depth,\n        strictDepth: true,\n        parameterLimit: parameterLimit\n      });\n    } catch (err) {\n      if (err instanceof RangeError) {\n        throw createError(400, 'The input exceeded the depth', {\n          type: 'querystring.parse.rangeError'\n        });\n      } else {\n        throw err;\n      }\n    }\n  };\n}\n\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\n\nfunction parameterCount(body, limit) {\n  var count = 0;\n  var index = 0;\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++;\n    index++;\n    if (count === limit) {\n      return undefined;\n    }\n  }\n  return count;\n}\n\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\n\nfunction parser(name) {\n  var mod = parsers[name];\n  if (mod !== undefined) {\n    return mod.parse;\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs');\n      break;\n    case 'querystring':\n      mod = require('querystring');\n      break;\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod;\n  return mod.parse;\n}\n\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\n\nfunction simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = parser('querystring');\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    debug('parse urlencoding');\n    return parse(body, undefined, undefined, {\n      maxKeys: parameterLimit\n    });\n  };\n}\n\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","createError","debug","deprecate","read","typeis","module","exports","urlencoded","parsers","Object","create","options","opts","extended","undefined","inflate","limit","parse","type","verify","depth","Number","TypeError","queryparse","extendedparser","simpleparser","shouldParse","typeChecker","body","length","urlencodedParser","req","res","next","_body","hasBody","headers","charset","getCharset","toUpperCase","encoding","parameterLimit","parser","isNaN","isFinite","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","strictDepth","err","RangeError","parameters","toLowerCase","e","count","index","indexOf","name","mod","maxKeys","checkType","Boolean"],"sources":["C:/Users/mepri/OneDrive/Desktop/Codes/PriDevelops/KhanaBadmosh/client/node_modules/body-parser/lib/types/urlencoded.js"],"sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar contentType = require('content-type')\r\nvar createError = require('http-errors')\r\nvar debug = require('debug')('body-parser:urlencoded')\r\nvar deprecate = require('depd')('body-parser')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = urlencoded\r\n\r\n/**\r\n * Cache of parser modules.\r\n */\r\n\r\nvar parsers = Object.create(null)\r\n\r\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\n\r\nfunction urlencoded (options) {\r\n  var opts = options || {}\r\n\r\n  // notice because option default will flip in next major\r\n  if (opts.extended === undefined) {\r\n    deprecate('undefined extended: provide extended option')\r\n  }\r\n\r\n  var extended = opts.extended !== false\r\n  var inflate = opts.inflate !== false\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var type = opts.type || 'application/x-www-form-urlencoded'\r\n  var verify = opts.verify || false\r\n  var depth = typeof opts.depth !== 'number'\r\n    ? Number(opts.depth || 32)\r\n    : opts.depth\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate query parser\r\n  var queryparse = extended\r\n    ? extendedparser(opts)\r\n    : simpleparser(opts)\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (body) {\r\n    return body.length\r\n      ? queryparse(body)\r\n      : {}\r\n  }\r\n\r\n  return function urlencodedParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // assert charset\r\n    var charset = getCharset(req) || 'utf-8'\r\n    if (charset !== 'utf-8') {\r\n      debug('invalid charset')\r\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n        charset: charset,\r\n        type: 'charset.unsupported'\r\n      }))\r\n      return\r\n    }\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      debug: debug,\r\n      encoding: charset,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify,\r\n      depth: depth\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction extendedparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n\r\n  var depth = typeof options.depth !== 'number'\r\n    ? Number(options.depth || 32)\r\n    : options.depth\r\n  var parse = parser('qs')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isNaN(depth) || depth < 0) {\r\n    throw new TypeError('option depth must be a zero or a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    var arrayLimit = Math.max(100, paramCount)\r\n\r\n    debug('parse extended urlencoding')\r\n    try {\r\n      return parse(body, {\r\n        allowPrototypes: true,\r\n        arrayLimit: arrayLimit,\r\n        depth: depth,\r\n        strictDepth: true,\r\n        parameterLimit: parameterLimit\r\n      })\r\n    } catch (err) {\r\n      if (err instanceof RangeError) {\r\n        throw createError(400, 'The input exceeded the depth', {\r\n          type: 'querystring.parse.rangeError'\r\n        })\r\n      } else {\r\n        throw err\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\n\r\nfunction getCharset (req) {\r\n  try {\r\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\r\n  } catch (e) {\r\n    return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\r\n\r\nfunction parameterCount (body, limit) {\r\n  var count = 0\r\n  var index = 0\r\n\r\n  while ((index = body.indexOf('&', index)) !== -1) {\r\n    count++\r\n    index++\r\n\r\n    if (count === limit) {\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  return count\r\n}\r\n\r\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\r\n\r\nfunction parser (name) {\r\n  var mod = parsers[name]\r\n\r\n  if (mod !== undefined) {\r\n    return mod.parse\r\n  }\r\n\r\n  // this uses a switch for static require analysis\r\n  switch (name) {\r\n    case 'qs':\r\n      mod = require('qs')\r\n      break\r\n    case 'querystring':\r\n      mod = require('querystring')\r\n      break\r\n  }\r\n\r\n  // store to prevent invoking require()\r\n  parsers[name] = mod\r\n\r\n  return mod.parse\r\n}\r\n\r\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction simpleparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n  var parse = parser('querystring')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    debug('parse urlencoding')\r\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}